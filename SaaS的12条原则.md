# SaaS开发的12条原则

> https://12factor.net/zh_cn

[TOC]

## 1 codebase

1. 一份代码，多份部署。不同的环境、阶段的部署共享同样的基准代码，不同点可以是配置或者一小部分不影响基准原则的组件功能。

## 2 显示依赖

1. 应用程序不会隐式依赖系统级的类库。 它一定通过 依赖清单 ，确切地声明所有依赖项。此外，在运行过程中通过 依赖隔离 工具来确保程序不会调用系统中存在但清单中未声明的依赖项。这一做法会统一应用到生产和开发环境。

2. Python 中则可分别使用两种工具 – Pip 用作依赖声明， Virtualenv 用作依赖隔离。

## 3 代码和配置严格分离

1. 配置文件在各部署间可存在大幅差异，代码却需完全一致。

2. 这里定义的“配置”并不包括应用的内部配置，比如 Rails 的 config/routes.rb，或是使用 Spring 时 代码模块间的依赖注入关系 。这类配置在不同部署间不存在差异，所以应该写入代码。

3. 推荐将应用的配置存储于 环境变量 中（ env vars, env ）

## 4 把后端服务当作附加资源

1. *后端服务*是指程序运行所需要的通过网络调用的各种服务，如数据库（[MySQL](http://dev.mysql.com/)，[CouchDB](http://couchdb.apache.org/)），消息/队列系统（[RabbitMQ](http://www.rabbitmq.com/)，[Beanstalkd](https://beanstalkd.github.io/)），SMTP 邮件发送服务（[Postfix](http://www.postfix.org/)），以及缓存系统（[Memcached](http://memcached.org/)）。
2. 后端服务，通常由部署应用程序的系统管理员一起管理。除了本地服务之外，应用程序有可能使用了第三方发布和管理的服务。示例包括 SMTP（例如 [Postmark](http://postmarkapp.com/)），数据收集服务（例如 [New Relic](http://newrelic.com/) 或 [Loggly](http://www.loggly.com/)），数据存储服务（如 [Amazon S3](http://http//aws.amazon.com/s3/)），以及使用 API 访问的服务（例如 [Twitter](http://dev.twitter.com/), [Google Maps](https://developers.google.com/maps/), [Last.fm](http://www.last.fm/api)）。
3. 不要把后端服务绑定到代码中，可以随时按需更改后端服务的实现细节（如更改数据库类型、恢复备份的数据库）而不用修改代码。

## 5 严格分离构建和运行

构建，发布，运行。

基准代码 转化为一份部署(非开发环境)需要以下三个阶段：

1.  构建阶段 是指将代码仓库转化为可执行包的过程。构建时会使用指定版本的代码，获取和打包 依赖项，编译成二进制文件和资源文件。 
2. 发布阶段 会将构建的结果和当前部署所需 配置 相结合，并能够立刻在运行环境中投入使用。
3.  运行阶段 （或者说“运行时”）是指针对选定的发布版本，在执行环境中启动一系列应用程序 进程。

## 6 以一个或多个无状态进程运行应用

1. 应用的进程必须无状态且 无共享 。 任何需要持久化的数据都要存储在 后端服务 内，比如数据库。

2. 内存区域或磁盘空间可以作为进程在做某种事务型操作时的缓存，例如下载一个很大的文件，对其操作并将结果写入数据库的过程。
3. Session 中的数据应该保存在诸如 Memcached 或 Redis 这样的带有过期时间的缓存中。

## 7 通过端口绑定(*Port binding*)来提供服务

1. 应用完全自我加载 而不依赖于任何网络服务器就可以创建一个面向网络的服务。互联网应用 通过端口绑定来提供服务 ，并监听发送至该端口的请求。
2. 将网络服务器类库通过 [依赖声明](https://12factor.net/zh_cn/dependencies) 载入应用。Python 的 [Tornado](http://www.tornadoweb.org/), Ruby 的[Thin](http://code.macournoyer.com/thin/) , Java 以及其他基于 JVM 语言的 [Jetty](http://www.eclipse.org/jetty/)。
3. 完全由 *用户端* ，确切的说应该是应用的代码，发起请求。和运行环境约定好绑定的端口即可处理这些请求。
4. 端口绑定这种方式也意味着一个应用可以成为另外一个应用的 [后端服务](https://12factor.net/zh_cn/backing-services) ，调用方将服务方提供的相应 URL 当作资源存入 [配置](https://12factor.net/zh_cn/config) 以备将来调用。

## 8 通过进程模型进行扩展

1. 开发人员可以运用这个模型去设计应用架构，将不同的工作分配给不同的 *进程类型* 。例如，HTTP 请求可以交给 web 进程来处理，而常驻的后台工作则交由 worker 进程负责。
2. 但一台独立的虚拟机的扩展有瓶颈（垂直扩展），所以应用程序必须可以在多台物理机器间跨进程工作。
3. 应用的进程 [不需要守护进程](http://dustin.github.com/2010/02/28/running-processes.html) 或是写入 PID 文件。相反的，应该借助操作系统的进程管理器(例如 [systemd](https://www.freedesktop.org/wiki/Software/systemd/) ，分布式的进程管理云平台，或是类似 [Foreman](http://blog.daviddollar.org/2011/05/06/introducing-foreman.html) 的工具)，来管理 [输出流](https://12factor.net/zh_cn/logs) ，响应崩溃的进程，以及处理用户触发的重启和关闭超级进程的请求。

## 9 快速启动和优雅终止可最大化健壮性

1. **应用的 [进程](https://12factor.net/zh_cn/processes) 是 \*易处理（disposable）\*的，意思是说它们可以瞬间开启或停止。** 这有利于快速、弹性的伸缩应用，迅速部署变化的 [代码](https://12factor.net/zh_cn/codebase) 或 [配置](https://12factor.net/zh_cn/config) ，稳健的部署应用。
2. 进程应当追求 **最小启动时间** 。
3. 进程 **一旦接收 [终止信号（`SIGTERM`）](http://en.wikipedia.org/wiki/SIGTERM) 就会优雅的终止** ：
   1. 就网络进程而言，优雅终止是指停止监听服务的端口，此类型的进程所隐含的要求是HTTP请求大多都很短(不会超过几秒钟)
   2. 对于 worker 进程来说，优雅终止是指将当前任务退回队列，此类型的进程所隐含的要求是，任务都应该 [可重复执行](http://en.wikipedia.org/wiki/Reentrant_(subroutine)) ， 这主要由将结果包装进事务或是使重复操作 [幂等](http://en.wikipedia.org/wiki/Idempotence) 来实现。
4. 进程还应当**在面对突然死亡时保持健壮**。一种推荐的方式是使用一个健壮的后端队列，例如 [Beanstalkd](https://beanstalkd.github.io/) ，它可以在客户端断开或超时后自动退回任务。

## 10 开发环境与线上环境等价

1. 尽可能的保持开发，预发布，线上环境相同
2. 应用想要做到 持续部署 就必须缩小本地与线上差异
3. 后端服务 是保持开发与线上等价的重要部分，例如数据库，队列系统，以及缓存。
4. 开发人员有时会觉得在本地环境中使用轻量的后端服务具有很强的吸引力，而那些更重量级的健壮的后端服务应该使用在生产环境。因此，许多语言都提供了简化获取后端服务的类库，例如不同类型服务的 *适配器* 。将本地端轻量级后端的调用和上线后重量级后端的调用进行适配。
5. 应用的开发人员应该反对在不同环境间使用不同的后端服务 ，即使适配器已经可以几乎消除使用上的差异。因为不同的后端服务意味着会突然出现的不兼容，从而导致测试、预发布都正常的代码在线上出现问题。



## 11 日志

1. 把日志当作事件流
2. 在基于服务器的环境中，日志通常被写在硬盘的一个文件里，但这只是一种输出格式。
3. 日志应该是 事件流 的汇总，将所有运行中进程和后端服务的输出流按照时间顺序收集起来。
4. 应用本身从不考虑存储自己的输出流。 不应该试图去写或者管理日志文件。相反，每一个运行的进程都会直接的标准输出（stdout）事件流。开发环境中，开发人员可以通过这些数据流，实时在终端看到应用的活动。
5. 在预发布或线上部署中，每个进程的输出流由运行环境截获，并将其他输出流整理在一起，然后一并发送给一个或多个最终的处理程序，用于查看或是长期存档。这些存档路径对于应用来说不可见也不可配置，而是完全交给程序的运行环境管理。类似 Logplex 和 Fluentd 的开源工具可以达到这个目的。
6. 输出流可以发送到 [Splunk](http://www.splunk.com/) 这样的日志索引及分析系统，或 [Hadoop/Hive](http://hive.apache.org/) 这样的通用数据存储系统。

## 12 管理进程

1. 后台管理任务当作一次性进程运行
2. 进程构成（process formation）是指用来处理应用的常规业务（比如处理 web 请求）的一组进程
3. 开发人员经常希望执行一些管理或维护应用的一次性任务
4. 